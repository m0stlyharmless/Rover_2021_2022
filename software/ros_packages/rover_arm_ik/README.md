# Rover Arm IK Packages Overview

This document provides a brief overview of the main software packages responsible for autonomous operation of the arm. This document aims to inform members about the structure an purpose of each package, as well as how to launch different files for simulation and control. Two main libraries allow us the functionality to preform autonomous operations with the arm: ROS_Control and Moveit!. Moveit! provides us with a number of different plugins and packages for simulating motion, motion planning, and improved kinematics on our arm. ROS Control provides us with the framework to connect the planned motions from Moveit! libraries with the actual hardware of the arm. In the sections below, a more in depth overview of how these two libraries function is presented.

## Package Descriptions

### rover_arm_control

The `rover_arm_control` package encompasses the code responsible for linking simulated/planned motions to real robot hardware. It is the implementation of the ROS Control library. The main pieces of software in this package are the hardware interface, and the joint controllers. Joint controllers are the ROS nodes responsible for keeping track of information about the joints of the arm. Joint controllers in the simplest sense, are what are responsible for taking commands from simulated/planned motion and executing it on the physical arm. The hardware interface is repsonsible for providing these controllers with the capability to interface with the real hardware of the arm.

### rover_arm_description

The `rover_arm_description` package is what stores the URDF model for the arm. The URDF model file is what contains information about limits and physical characteristics of every joint on the arm. It is what tells the simulator and the control package how the joints are linked together and how they interact with one another. The files in this package are used by many of the packages for arm autonomy.

### rover_arm_gazebo

The `rover_arm_gazebo` package is responsible for taking the URDF model of the arm and launching it in Gazebo- a full 3D physics simulator. Gazebo provides a good approximation of real life behavior of the arm through simulation. This package contains joint controllers that publish false joint data for simulation purposes, so the simulation here is not connected to actual hardware. 

### rover_arm_moveit_config

The `rover_arm_moveit_config` package was autogenerated using the Moveit! setup assistant. It is responsible for storing the kinematics, path planning, and joint limits information for using the arm in simulation and real life.

### stomp_core

`stomp_core` is responsible for holding the core code that makes up the STOMP Planning library used in Moveit! 

### stomp_moveit

`stomp_moveit` is the package that holds the plugin information for using STOMP with Moveit!

### fake_ros_control

`fake_ros_control` essentially mimics the `rover_arm_control` package except for it does not include the libraries for interfacing with hardware. The purpose of this package is to provide a way to test the joint controllers used on the actual robot without them being connected to actual hardware. This package provides a hardware interface that simulates a perfect feedback loop of joint states while following actual joint limits specifed by the URDF.

### rover_arm_ikfast_plugin

`rover_arm_ikfast_plugin` houses the code that allows Moveit! to use the IKFast solver for inverse kinematics. The code in this package was autogenerated using the tutorial on generating IK solutions below.

## Simulating Arm Control Using RViz and Gazebo
The below instructions have information on simulating the arm using a fake ros control node and visualizing it in RViz and Gazebo. The fake ros control is a feedback loop that publishes fake joint states and obeys joint limits so the arm can be tested independantly of a hardware connection.

1. Launch the fake ros control node using the command `roslaunch fake_ros_control fake_arm_control.launch`. This spins up a ros_control node connected to a hardware interface that will listen to commands from Moveit! but bypasses the need for hardware by storing and reassigning current and previous joint information. It heeds joint limits specified in the URDF so it will respond similarly to the real robot.

1. Start RViz using the command `roslaunch rover_arm_moveit_config sim_control.launch`. This starts RViz with parameters for using ros control as well as actually starts Moveit! and the FollowJointTrajectory action server. Basically this launch file connects Moveit! to the fake ros control node.

## Running the Arm With ROS Control
ROS Control provides the functionality to link motion planning done in Moveit! to actual execution on the physical rover. This is done using what is called a hardware interface, which basically takes the commands published by Moveit! and translates them to signals used by the hardware to actuate the joints of the arm. This section discusses how to use the actual version of ros control/IK on the rover.

1. Start the groundstation and launch the rover main files

1. Under the `Arm Controls` tab on the groundstation, press the `start ik` button. This sends a signal to the hardware interface node toggling a boolean to true so the controllers can start. Wait for the node to spin up. If the node has launched correctly, you should see the IK indicator change color to green.

1. Tab to the Moveit! tab on the groundstation. An instance of RViz should be running, which you can use to plan motions from. Make sure STOMP is selected as the motion planner. 

1. **IMPORTANT!** When planning motions on the actual arm, do not just hit plan and execute!!! Make sure you plan first and verify that there are no weird motions in the path. The weird motions *should* be caught and not executed all the way, but it's not a 100% guarantee that the arm won't try to execute a path out of its range of motion. Please, please verify that the paths are correct before executing as the current state of the arm is not refined enough yet to catch errors like that.

1. To shut down ros control, simply press the stop IK button and the controllers will stop running. If the interface succesfully shuts down, the IK status indicator should return to red.

## Generating IK Solutions and Plugins

The below instructions were adapted from the official Moveit! Documentatation on IKFAST. A link to these docs can be found in the references section at the end of this document. These instructions assume you already have installed OpenRAVE on your machine. If you need to do that a good tutorial can be found [here](https://scaron.info/teaching/installing-openrave-on-ubuntu-16.04.html). <br>

### 1. Converting URDF to COLLADA

IKFAST works with a 3D file type called COLLADA (COLLAborative Design Activity). The standard file used for Moveit! is URDF, so in order to utilize OpenRAVE and IKFAST, URDF files must be converted to COLLADA. Luckily, there is a nice script that is meant for this specific purpose. <br>

* First, run `sudo apt-get install ros-kinetic-collada-urdf` to install the necessary scripts for conversion
* Make sure to create an environment variable with the name of your robot/URDF. You can do this using the command `export MYROBOT_NAME="[your robot name]"`. where the robot name matches the name of the URDF and COLLADA file.
* Then, run `rosrun collada_urdf urdf_to_collada "$MYROBOT_NAME".urdf "$MYROBOT_NAME".dae` where `$MYROBOT_NAME` is the file name and path for the URDF file to be converted.
* To test if the file has been correctly converted run `openrave "$MYROBOT_NAME".dae` where `$MYROBOT_NAME` is the file name and path for the COLLADA file
* Joint link information can be displayed with the command `openrave-robot.py "$MYROBOT_NAME".dae --info links` where `$MYROBOT_NAME` is the file name and path for the COLLADA file

### 2. Generating Solution CPP File

In order to use IK with Moveit!, a solution file has to be generated. This file is generated by OpenRAVE and is a mathematical analysis of the joints of the input COLLADA file. Typical inverse kinematics calculations make extensive use of linear algebra and trigonometry, but an understanding of higher mathematics is not necessary to run OpenRAVE and generate the solution file. For more mathematically curious/inclined members: Angela Sodemann, an assistant professor at Arizona State University, has an entire free lecture video series about robotics principles, including all the mathematics behind them. Her youtube channel can be found [here](https://www.youtube.com/user/asodemann3/videos) <br>

1. First, the type of IK needs to be selected. There are about 11 different types of IK that are supported by OpenRAVE and an extensive list can be found [here](http://openrave.org/docs/latest_stable/openravepy/ikfast/#ik-types). The default type of IK is `Transform6D` which means that the end effector will reach a desired transformation in 6D space. The type of IK chosen will be specified as the variable `iktype=[desired ik type]`.
1. Next, a planning group must be chosen. This planning group name is the same as what is specified in the srdf file generated by the Moveit! Setup. Set this to an environment variable using the command `export PLANNING_GROUP="group_name"` where `group_name` is the planning name from the SRDF file.
1. In order to properly generate a solution file for IK, the end effector and base links need to be specified. To get the joint information run the command `openrave-robot.py "$MYROBOT_NAME".dae --info links` where `$MYROBOT_NAME` is the file name and path for the COLLADA file.
1. Once the above command is run, identify the numbers corresponding to the base and end effector link. These can then be exported as environment variables `export BASE_LINK="N"` and `export EEF_LINK="N"` where `N` is the number corresponding to the links.
1. Now it's time to set the name for the output file. Moveit!'s recommended naming can be generated by using the following command ``` `export IKFAST_OUTPUT_PATH=`pwd`/ikfast61_"$PLANNING_GROUP".cpp ```. Make sure to do this within the `config` folder of the `moveit_config` package for your robot.
1. Finally, for a 6DOF arm, run the following command to actually generate the IK solution file python ``` `openrave-config --python-dir`/openravepy/_openravepy_/ikfast.py --robot="$MYROBOT_NAME".dae --iktype=[desired ik type] --baselink="$BASE_LINK" --eelink="$EEF_LINK" --savefile="$IKFAST_OUTPUT_PATH" ```. Make sure to replace `[desired ik type]` with the IK type selected earlier. 
    1. A note: The solution process shouldn't take over an hour! Typically solutions can be generated under 10 minutes, but every robot is different. If this ends up occuring, run the commands: ```export IKFAST_PRECISION="5" cp "$MYROBOT_NAME".dae "$MYROBOT_NAME".backup.dae``` ```rosrun moveit_kinematics round_collada_numbers.py "$MYROBOT_NAME".dae "$MYROBOT_NAME".dae "$IKFAST_PRECISION"``` Where ```$MYROBOT_NAME```  is the file name and path for the COLLADA file. This command rounds off the numbers in the COLLADA file, which makes the math easier for the solver to perform.

    1. As the command runs, you can actually see a bit of the linear algebra that's being performed! 
1. Once the IK solution file is generated, it can then be used in plugins!

### 3. Generating a Plugin Library for Moveit!

Once the IK solution file is generated, it can be used to create a plugin for IKFAST in Moveit!. Moveit! uses a file called `kinematics.yaml` to control which kinematics plugin is used. This section details how to create the IKFAST plugin for Moveit! and essentially follows the official tutorial put out by Moveit! The official tutorial can be found [here](https://docs.ros.org/en/kinetic/api/moveit_tutorials/html/doc/ikfast/ikfast_tutorial.html#create-plugin). <br>

1. First, a package to store the plugin needs to be created. This can be done by executing the following commands:
    1. `export MOVEIT_IK_PLUGIN_PKG="$MYROBOT_NAME"_ikfast_"$PLANNING_GROUP"_plugin`
    1. `cd ~/[your catkin workspace]/src`
    1. `catkin_create_pkg "$MOVEIT_IK_PLUGIN_PKG"`
    1. cd back into your catkin workspace's main folder and run `catkin_make` to finish creating the package
1. Create the source code using the command ```rosrun moveit_kinematics create_ikfast_moveit_plugin.py "$MYROBOT_NAME" "$PLANNING_GROUP" "$MOVEIT_IK_PLUGIN_PKG" "$IKFAST_OUTPUT_PATH"```
1. cd into the main folder your catkin workspace and `catkin_make`. 
1. You're done! Now you can launch your robot in RViz and verify the ik solver works!

## References

### General References for Moveit! and Gazebo

[Official Moveit! Documentation](https://docs.ros.org/en/kinetic/api/moveit_tutorials/html/index.html) <br>
[Official Gazebo Documentation for ROS](http://gazebosim.org/tutorials?cat=connect_ros)


### ROS Control Resources

[ROS Control Boilerplate Code](https://github.com/PickNikRobotics/ros_control_boilerplate/tree/kinetic-devel) by PikNik Robotics <br>
[ROS Control Tutorial](https://medium.com/%40slaterobotics/how-to-implement-ros-control-on-a-custom-robot-748b52751f2e) by Slate Robotics <br>
[Official ROS Control Repository](https://github.com/ros-controls/ros_control)

### Inverse Kinematics Resources

[Documentation for using Moveit! and IKFAST](https://docs.ros.org/en/kinetic/api/moveit_tutorials/html/doc/ikfast/ikfast_tutorial.html) <br>
[Offical OpenRAVE documentation](http://www.openrave.org/docs/latest_stable/) <br>
[Installing OpenRAVE tutotrial](https://scaron.info/teaching/installing-openrave-on-ubuntu-16.04.html) <br>
[Lecture Videos Covering Kinematics Math](https://www.youtube.com/user/asodemann3/videos) <br>
